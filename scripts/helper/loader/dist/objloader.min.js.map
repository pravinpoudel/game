{"version":3,"sources":["objloader.js"],"names":["objLoader","response","text","lines","regexKeyword","material","group","geometries","geometry","webglData","positionCordinate","textureCordinate","normalCordinate","vertexColor","vertexData","addVertex","max","setGeometry","addMethods","geometryRange","getRange","i","length","line","result","_result","keyword","datas","handlerFunction","minMax","regeneratorRuntime","async","_context","prev","next","reduce","_ref","_ref2","min","vertexPosition","attributes","position","index","Math","map","verticesIndices","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","data","slice","j","texCord","normalCord","colorValue","push","undefined","split","forEach","_webglData$i","_webglData$","apply","_toConsumableArray","awrap","fetch","sent","vt","resetGeometry","f","traingleCount","indices","usemtl","trim","abrupt","_slicedToArray","console","warn","concat","stop"],"mappings":"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","file":"objloader.min.js","sourcesContent":["async function objLoader() {\r\n  const response = await fetch(\"/game/resources/models/objs/Chair/Chair.obj\");\r\n  const text = await response.text();\r\n  const lines = text.split(\"\\n\");\r\n  const regexKeyword = /(\\w*)(?: )*(.*)/;\r\n  let material = \"basic\";\r\n  let object = \"default\";\r\n  let group = \"\";\r\n  let verticesIndices = [];\r\n\r\n  let geometries = [];\r\n  let geometry;\r\n\r\n  let webglData = [[], [], [], []];\r\n\r\n  let positionCordinate = [[0, 0, 0]];\r\n  let textureCordinate = [[0, 0]];\r\n  let normalCordinate = [[0, 0, 0]];\r\n  let vertexColor = [[0, 0, 0]];\r\n\r\n  let vertexData = [\r\n    positionCordinate,\r\n    textureCordinate,\r\n    normalCordinate,\r\n    vertexColor,\r\n  ];\r\n\r\n  function addVertex(data) {\r\n    let indices = data.split(\"/\");\r\n    indices.forEach((index, i) => {\r\n      if (!index) {\r\n        return;\r\n      }\r\n      index = index > 0 ? index : index + vertexData[i].length;\r\n      webglData[i].push(...vertexData[i][index]);\r\n      // add color value of that vertex which is i=0 to the webgl data\r\n      if (i === 0) {\r\n        webglData[3].push(...vertexColor[index]);\r\n      }\r\n    });\r\n  }\r\n\r\n  function resetGeometry() {\r\n    if (geometry) {\r\n      geometry = undefined;\r\n    }\r\n  }\r\n\r\n  function setGeometry() {\r\n    if (!geometry) {\r\n      const position = [];\r\n      const texCord = [];\r\n      const normalCord = [];\r\n      const colorValue = [];\r\n      webglData = [position, texCord, normalCord, colorValue];\r\n\r\n      geometry = {\r\n        group,\r\n        material,\r\n        attributes: {\r\n          position,\r\n          texCord,\r\n          normalCord,\r\n          colorValue,\r\n        },\r\n      };\r\n\r\n      geometries.push(geometry);\r\n    }\r\n  }\r\n\r\n  let addMethods = {\r\n    v(data) {\r\n      if (data.length > 3) {\r\n        positionCordinate.push(data.slice(0, 3));\r\n        vertexColor.push(data.slice(3));\r\n      } else {\r\n        positionCordinate.push(data);\r\n        vertexColor.push([1, 1, 1]);\r\n      }\r\n    },\r\n    vt(data) {\r\n      textureCordinate.push(data);\r\n    },\r\n    vn(data) {\r\n      normalCordinate.push(data);\r\n    },\r\n    f(data) {\r\n      setGeometry();\r\n      for (let i = 0, traingleCount = data.length - 2; i < traingleCount; i++) {\r\n        addVertex(data[0]);\r\n        addVertex(data[i + 1]);\r\n        addVertex(data[i + 2]);\r\n      }\r\n    },\r\n    usemtl(data) {\r\n      resetGeometry();\r\n      material = data;\r\n    },\r\n    o(data) {\r\n      object = data;\r\n    },\r\n  };\r\n\r\n  function geometryRange(data) {\r\n    let min = data.slice(0, 3);\r\n    let max = data.slice(0, 3);\r\n\r\n    for (let i = 0, length = data.length; i < length; i += 3) {\r\n      for (let j = 0; j < 3; j++) {\r\n        min[j] = Math.min(min[j], data[i + j]);\r\n        max[j] = Math.max(max[j], data[i + j]);\r\n      }\r\n    }\r\n    return { min, max };\r\n  }\r\n\r\n  function getRange(geometries) {\r\n    return geometries.reduce(\r\n      ({ min, max }, { attributes }) => {\r\n        const vertexPosition = attributes.position;\r\n        let minMax = geometryRange(vertexPosition);\r\n        return {\r\n          min: min.map((min, index) => Math.min(min, minMax.min[index])),\r\n          max: max.map((max, index) => Math.max(max, minMax.max[index])),\r\n        };\r\n      },\r\n      {\r\n        min: Array(3).fill(Number.POSITIVE_INFINITY),\r\n        max: Array(3).fill(Number.NEGATIVE_INFINITY),\r\n      }\r\n    );\r\n  }\r\n\r\n  for (let i = 0, length = lines.length; i < length; i++) {\r\n    let line = lines[i].trim();\r\n    if (line === \"\" || line.startsWith(\"#\")) {\r\n      continue;\r\n    }\r\n    let result = regexKeyword.exec(line);\r\n    if (!result) {\r\n      continue;\r\n    }\r\n    const [, keyword, unparsedArgs] = result;\r\n    let datas = line.split(/\\s+/).slice(1);\r\n    const handlerFunction = addMethods[keyword];\r\n    if (!handlerFunction) {\r\n      console.warn(`${keyword} isnot handled by this program`);\r\n      continue;\r\n    }\r\n    handlerFunction(datas);\r\n  }\r\n  let minMax = getRange(geometries);\r\n  return {\r\n    geometries,\r\n    minMax,\r\n  };\r\n}\r\n"]}