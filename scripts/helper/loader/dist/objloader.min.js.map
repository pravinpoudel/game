{"version":3,"sources":["objloader.js"],"names":["matLib","objLoader","response","text","lines","regexKeyword","material","group","geometries","geometry","webglData","positionCordinate","textureCordinate","normalCordinate","vertexColor","vertexData","addVertex","max","setGeometry","addMethods","geometryRange","getRange","i","length","line","result","_result","keyword","datas","handlerFunction","_i2","_length","minMax","regeneratorRuntime","async","_context2","prev","next","reduce","_ref","_ref2","split","position","vertexPosition","object","min","map","index","Math","verticesIndices","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","data","slice","j","fetch","texCord","normalCord","colorValue","push","undefined","forEach","attributes","_webglData$i","_webglData$","apply","_toConsumableArray","awrap","sent","vt","resetGeometry","f","traingleCount","indices","mtllib","usemtl","o","abrupt","_slicedToArray","vn","console","warn","concat","window","location","href","materialURL","URL","element","url","stop"],"mappings":"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","file":"objloader.min.js","sourcesContent":["const matLib = [];\r\n\r\nasync function objLoader() {\r\n  const response = await fetch(\"/game/resources/models/objs/Chair/Chair.obj\");\r\n  const text = await response.text();\r\n  const lines = text.split(\"\\n\");\r\n  const regexKeyword = /(\\w*)(?: )*(.*)/;\r\n  let material = \"basic\";\r\n  let object = \"default\";\r\n  let group = \"\";\r\n  let verticesIndices = [];\r\n\r\n  let geometries = [];\r\n  let geometry;\r\n\r\n  let webglData = [[], [], [], []];\r\n\r\n  let positionCordinate = [[0, 0, 0]];\r\n  let textureCordinate = [[0, 0]];\r\n  let normalCordinate = [[0, 0, 0]];\r\n  let vertexColor = [[0, 0, 0]];\r\n\r\n  let vertexData = [\r\n    positionCordinate,\r\n    textureCordinate,\r\n    normalCordinate,\r\n    vertexColor,\r\n  ];\r\n\r\n  function addVertex(data) {\r\n    let indices = data.split(\"/\");\r\n    indices.forEach((index, i) => {\r\n      if (!index) {\r\n        return;\r\n      }\r\n      index = index > 0 ? index : index + vertexData[i].length;\r\n      webglData[i].push(...vertexData[i][index]);\r\n      // add color value of that vertex which is i=0 to the webgl data\r\n      if (i === 0) {\r\n        webglData[3].push(...vertexColor[index]);\r\n      }\r\n    });\r\n  }\r\n\r\n  function resetGeometry() {\r\n    if (geometry) {\r\n      geometry = undefined;\r\n    }\r\n  }\r\n\r\n  function setGeometry() {\r\n    if (!geometry) {\r\n      const position = [];\r\n      const texCord = [];\r\n      const normalCord = [];\r\n      const colorValue = [];\r\n      webglData = [position, texCord, normalCord, colorValue];\r\n\r\n      geometry = {\r\n        group,\r\n        material,\r\n        attributes: {\r\n          position,\r\n          texCord,\r\n          normalCord,\r\n          colorValue,\r\n        },\r\n      };\r\n\r\n      geometries.push(geometry);\r\n    }\r\n  }\r\n\r\n  let addMethods = {\r\n    v(data) {\r\n      if (data.length > 3) {\r\n        positionCordinate.push(data.slice(0, 3));\r\n        vertexColor.push(data.slice(3));\r\n      } else {\r\n        positionCordinate.push(data);\r\n        vertexColor.push([1, 1, 1]);\r\n      }\r\n    },\r\n    vt(data) {\r\n      textureCordinate.push(data);\r\n    },\r\n    vn(data) {\r\n      normalCordinate.push(data);\r\n    },\r\n    f(data) {\r\n      setGeometry();\r\n      for (let i = 0, traingleCount = data.length - 2; i < traingleCount; i++) {\r\n        addVertex(data[0]);\r\n        addVertex(data[i + 1]);\r\n        addVertex(data[i + 2]);\r\n      }\r\n    },\r\n    mtllib(data) {\r\n      matLib.push(data);\r\n    },\r\n    usemtl(data) {\r\n      resetGeometry();\r\n      material = data;\r\n    },\r\n    o(data) {\r\n      object = data;\r\n    },\r\n  };\r\n\r\n  function geometryRange(data) {\r\n    let min = data.slice(0, 3);\r\n    let max = data.slice(0, 3);\r\n\r\n    for (let i = 0, length = data.length; i < length; i += 3) {\r\n      for (let j = 0; j < 3; j++) {\r\n        min[j] = Math.min(min[j], data[i + j]);\r\n        max[j] = Math.max(max[j], data[i + j]);\r\n      }\r\n    }\r\n    return { min, max };\r\n  }\r\n\r\n  function getRange(geometries) {\r\n    return geometries.reduce(\r\n      ({ min, max }, { attributes }) => {\r\n        const vertexPosition = attributes.position;\r\n        let minMax = geometryRange(vertexPosition);\r\n        return {\r\n          min: min.map((min, index) => Math.min(min, minMax.min[index])),\r\n          max: max.map((max, index) => Math.max(max, minMax.max[index])),\r\n        };\r\n      },\r\n      {\r\n        min: Array(3).fill(Number.POSITIVE_INFINITY),\r\n        max: Array(3).fill(Number.NEGATIVE_INFINITY),\r\n      }\r\n    );\r\n  }\r\n\r\n  for (let i = 0, length = lines.length; i < length; i++) {\r\n    let line = lines[i].trim();\r\n    if (line === \"\" || line.startsWith(\"#\")) {\r\n      continue;\r\n    }\r\n    let result = regexKeyword.exec(line);\r\n    if (!result) {\r\n      continue;\r\n    }\r\n    const [, keyword, unparsedArgs] = result;\r\n    let datas = line.split(/\\s+/).slice(1);\r\n    const handlerFunction = addMethods[keyword];\r\n    if (!handlerFunction) {\r\n      console.warn(`${keyword} isnot handled by this program`);\r\n      continue;\r\n    }\r\n    handlerFunction(datas);\r\n  }\r\n\r\n  matLib.forEach(async (element, index) => {\r\n    let url = new URL(\"./resources/models/objs/Chair/\", window.location.href);\r\n    let materialURL = new URL(element, url);\r\n    const response = await (await fetch(materialURL)).text();\r\n    const lines = response.split(\"\\n\");\r\n  });\r\n\r\n  for (let i = 0, length = lines.length; i < length; i++) {\r\n    const data = lines[i].trim();\r\n  }\r\n\r\n  let minMax = getRange(geometries);\r\n  return {\r\n    geometries,\r\n    minMax,\r\n  };\r\n}\r\n"]}