{"version":3,"sources":["sphere.js"],"names":["numbLatitude","numbLongitude","radius","indices","index","i","theta","Math","PI","sintheta","cos","costheta","j","phi","sinphi","sin","cosinephi","x","y","vertices","console","log","concat","length","p0","p1"],"mappings":"aAAA,IAAMA,aAAe,GACfC,cAAgB,GADhBD,OAAAA,GACAC,SAAa,GACbC,QAAN,GAEA,SAAMC,oBAGJ,IAAA,IAAIC,EAAQ,EAAHC,EAAT,EAAAA,GAAAL,aAAAK,IAAA,CAGEC,MAASD,EAAIE,KAAKC,GAAMR,aAExB,IAHF,IAAKS,EAAYF,KAAIP,IAAAA,OACnBM,EAAaC,KAALG,IAAgBV,OAEpBW,EAAQ,EAAGJ,GAAKG,cAApBE,IAAA,CAGE,IAAIC,EAAOD,GAAK,EAAML,KAAKC,IAAOP,cAD/Ba,EAALP,KAAiBQ,IAAId,GACfY,EAAYN,KAAMA,IAAIM,GAEtBG,EAAAA,OAAYT,EAAAS,EAEZC,EAAIf,OAASO,EACbS,EAAIhB,OAASS,EAAjBG,EACAK,SAAQjB,KAASO,EACjBU,SAASf,KAAWa,EACpBE,SAASf,KAAWc,GAKxBE,QAAQC,IAAR,aAAAC,OAAyBlB,IAGpB,IAAIC,EADTD,EAAQ,EACR,IAAoBe,SAASI,OAAQlB,GAAKL,aAAcK,IAAxD,IAAK,IAAKO,EAAL,EAAWK,GAAIE,cAApBP,IAAsC,CACpC,IAAKY,EAAKnB,GAAVJ,cAAqBA,GAArBW,EACMY,EAAKnB,EAACJ,cAAiB,EAE3BE,QAAQC,KAAWoB,EAEnBrB,QAAQC,KAAWqB,EAFnBtB,QAAQC,KAAWoB,EAAnB,EAGArB,QAAQC,KAAWoB,EAEnBrB,QAAQC,KAAWqB,EAAnB,EACAtB,QAAQC,KAAWqB,EAAK,EAK5B,OAFCL,QAAAC,IAAA,aAAAC,OAAAlB,IAEM,CAACe,SAAUhB","file":"sphere.min.js","sourcesContent":["const numbLatitude = 50;\r\nconst numbLongitude = 50;\r\nconst radius = 0.5;\r\nconst vertices = [];\r\nconst indices = [];\r\n\r\nfunction sphereVertIndices() {\r\n  let index = 0;\r\n\r\n  for (let i = 0; i <= numbLatitude; i++) {\r\n    theta = (i * Math.PI) / numbLatitude;\r\n    let sintheta = Math.sin(theta);\r\n    let costheta = Math.cos(theta);\r\n\r\n    for (let j = 0; j <= numbLongitude; j++) {\r\n      let phi = (j * (2.0 * Math.PI)) / numbLongitude;\r\n      let sinphi = Math.sin(phi);\r\n      let cosinephi = Math.cos(phi);\r\n\r\n      let x = radius * sintheta * cosinephi;\r\n      let y = radius * costheta;\r\n      let z = radius * sintheta * sinphi;\r\n      vertices[index++] = x;\r\n      vertices[index++] = y;\r\n      vertices[index++] = z;\r\n    }\r\n  }\r\n\r\n  console.log(`index1 is ${index}`);\r\n\r\n  index = 0;\r\n  for (let i = 0, x = vertices.length; i <= numbLatitude; i++) {\r\n    for (let j = 0; j <= numbLongitude; j++) {\r\n      let p0 = i * (numbLongitude + 1) + j; //remember not j+1;\r\n      let p1 = p0 + numbLongitude + 1; //dont forget to add 1;\r\n      indices[index++] = p0;\r\n\r\n      indices[index++] = p1;\r\n      indices[index++] = p0 + 1;\r\n\r\n      indices[index++] = p1;\r\n      indices[index++] = p1 + 1;\r\n      indices[index++] = p0 + 1;\r\n    }\r\n  }\r\n  console.log(`index2 is ${index}`);\r\n  return [vertices, indices];\r\n}\r\n"]}