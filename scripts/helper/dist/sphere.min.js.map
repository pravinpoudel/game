{"version":3,"sources":["sphere.js"],"names":["numbLatitude","numbLongitude","radius","indices","console","log","i","j","index","theta","Math","PI","sintheta","sin","costheta","cos","sinphi","phi","cosinephi","x","vertices","maxX","concat","p1","p0"],"mappings":"aAAA,IAAMA,aAAe,IACfC,cAAgB,IADhBD,OAAAA,EACAC,SAAa,GACbC,QAAN,GAEA,SAAMC,oBAIJ,IADA,IA0BAC,EAAQC,EAARC,EAAAC,EA1BIC,EAAQ,EAARA,EAAK,EACTF,EAAA,EAAAA,GAAAN,aAAAM,IAAA,CACAG,MAAWH,EAAXI,KAAAC,GAAAX,aAGE,IAAA,IAAIY,EAAWF,KAAKG,IAAIJ,OAFrBK,EAAWR,KAACS,IAAIf,OAEfY,EAAQ,EAAGF,GAAKG,cAApBN,IAAA,CACA,IAAIO,EAAQP,GAAGG,EAASD,KAATE,IAAfV,cAIMe,EAASN,KAAKG,IAAII,GAFnBC,EAAWX,KAAKN,IAAAA,GAEfe,EAAAA,OAAaJ,EAAjBM,EACIA,EAAAA,OAAYR,EAEZS,EAAIjB,OAASU,EAAWM,EAC5BE,SAAQlB,KAASY,EACjBM,SAAQlB,KAASU,EACjBQ,SAASZ,KAAWW,EACpBC,EAAQC,IACRD,EAASZ,IAUbA,IAPKJ,QAAAC,IAAAgB,GAEJjB,QAAAC,IAAA,mBAAAiB,OAAAd,IAKIF,EAJLF,EAAQC,EAIRC,GAAAN,aAAA,EAAAM,IACA,IAAAC,EAAA,EAAAA,GAAAN,cAAAM,IACAgB,GAEIC,EAAKlB,GAAKL,cAAgB,GAAKM,GAFtBN,cAAgB,EAC3BE,QAAAK,KAAiBP,EAKfE,QAAQK,KAAWe,EAHnBA,QAAOf,KAAGP,EAAL,EACLE,QAAQK,KAAWgB,EAEnBrB,QAAQK,KAAWe,EAAnB,EACApB,QAAQK,KAAWgB,EAAK,EAKzB,IAAAjB,EAAA,EAAAA,EAAAN,cAAAM,IAKDgB,GAJDC,EAAAlB,GAAAL,cAAA,GAAAM,GAIWN,cAAgB,EAF5BE,QAAAK,KAAgBP,EAEdsB,QAAOf,KAAGP,EACVE,QAAQK,KAAWgB,EAAnB,EAQFpB,OAJCA,QAAAC,IAAAmB,EAAAD,GAEDnB,QAAQC,IAARD,mBAAAA,OAAAI,IAEO,CAACH,SAARF","file":"sphere.min.js","sourcesContent":["const numbLatitude = 100;\r\nconst numbLongitude = 100;\r\nconst radius = 1.0;\r\nconst vertices = [];\r\nconst indices = [];\r\n\r\nfunction sphereVertIndices() {\r\n  let index = 0;\r\n  let u, v;\r\n  let maxX = 0.0;\r\n  for (let i = 0; i <= numbLatitude; i++) {\r\n    theta = (i * Math.PI) / numbLatitude;\r\n    let sintheta = Math.sin(theta);\r\n    let costheta = Math.cos(theta);\r\n\r\n    for (let j = 0; j <= numbLongitude; j++) {\r\n      let phi = (j * (2.0 * Math.PI)) / numbLongitude;\r\n      let sinphi = Math.sin(phi);\r\n      let cosinephi = Math.cos(phi);\r\n\r\n      let x = radius * sintheta * cosinephi;\r\n      let y = radius * costheta;\r\n      let z = radius * sintheta * sinphi;\r\n      vertices[index++] = x;\r\n      vertices[index++] = y;\r\n      vertices[index++] = z;\r\n      if (x < maxX) {\r\n        maxX = x;\r\n      }\r\n    }\r\n  }\r\n  console.log(maxX);\r\n\r\n  console.log(`index count1 is ${index}`);\r\n\r\n  index = 0;\r\n  let p0, p1, i, j;\r\n  for (i = 0; i <= numbLatitude - 2; i++) {\r\n    for (j = 0; j <= numbLongitude; j++) {\r\n      p0 = i * (numbLongitude + 1) + j; //remember not j+1;\r\n      p1 = p0 + numbLongitude + 1; //dont forget to add 1;\r\n      indices[index++] = p0;\r\n\r\n      indices[index++] = p1;\r\n      indices[index++] = p0 + 1;\r\n\r\n      indices[index++] = p1;\r\n      indices[index++] = p1 + 1;\r\n      indices[index++] = p0 + 1;\r\n    }\r\n  }\r\n\r\n  for (j = 0; j < numbLongitude; j++) {\r\n    p0 = i * (numbLongitude + 1) + j;\r\n    p1 = p0 + numbLongitude + 1;\r\n    indices[index++] = p0;\r\n\r\n    indices[index++] = p1;\r\n    indices[index++] = p0 + 1;\r\n  }\r\n\r\n  console.log(p0, p1);\r\n\r\n  console.log(`index count2 is ${index}`);\r\n  return [vertices, indices];\r\n}\r\n"]}